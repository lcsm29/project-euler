# Solution of;
# Project Euler Problem 12: Highly divisible triangular number
# https://projecteuler.net/problem=12
# 
# The sequence of triangle numbers is generated by adding the natural numbers.
# So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
# The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
# 
# Let us list the factors of the first seven triangle numbers: 
#        1: 1
#        3: 1, 3 
#        6: 1, 2, 3, 6
#       10: 1, 2, 5, 10
#       15: 1, 3, 5, 15
#       21: 1, 3, 7, 21
#       28: 1, 2, 4, 7, 14, 28
# 
# We can see that 28 is the first triangle number to have over 5 divisors.
# What is the value of the first triangle number to have over 500 divisors?
# 
# by lcsm29 http://github.com/lcsm29/project-euler
from time import perf_counter_ns
import timed
from math import sqrt

''' removed immediately because it is too slow
def fn_brute(n):
    assert n >= 2
    num_divs, i = 2, 1
    while num_divs <= n:
        i += 1
        triangle = int(0.5 * i * (i + 1))
        tmp_divs = 2
        for j in range(2, triangle // 2 + 1):
            if triangle % j == 0:
                tmp_divs += 1
        if tmp_divs > num_divs:
            num_divs = tmp_divs
    return int(0.5 * i * (i + 1))
'''

def fn_pfactor_based_brute(n): # this one is also too slow but it's the best one atm
    assert n > 1, 'n should be greater than 1'
    assert type(n) == int, 'n should be an integer'

    def get_smallest_prime(num):
        smallest = float('inf')
        for i in range(2, int(sqrt(num)) + 2):
            if num % i == 0:
                return min(smallest, i)
        return num

    def get_prime_factors(num):
        factors = []
        prime, divided = 2, num
        while prime <= divided:
            prime = get_smallest_prime(divided)
            if prime <= divided:
                divided //= prime
                factors.append(prime)
        return factors

    def get_combs(factors_lst):
        if len(factors_lst) == 0:
            return [[]]
        combinations = []
        for c in get_combs(factors_lst[1:]):
            combinations += [c, c + [factors_lst[0]]]
        return combinations

    def count_divs(combs_lst):
        dup_removed = []
        for l in combs_lst[1:]:
            if l not in dup_removed:
                dup_removed.append(l)
        return len(dup_removed) + 1
    
    num_divs, i = 2, 1
    while num_divs <= n:
        i += 1
        triangle = int(0.5 * i * (i + 1))
        num_divs = count_divs(get_combs(get_prime_factors(triangle)))
    return triangle
    

if __name__ == '__main__':
    n = 500
    i = 1
    prob_id = 12
    # timed.caller(fn_brute, n, i, prob_id)
    timed.caller(fn_pfactor_based_brute, n, i, prob_id)
